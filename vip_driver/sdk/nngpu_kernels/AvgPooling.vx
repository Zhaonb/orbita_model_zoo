#pragma OPENCL EXTENSION cl_viv_bitfield_extension : enable
#pragma OPENCL EXTENSION cl_viv_vx_extension : enable

__kernel void gpuPooling_AvgNoPadFP32
    (
    __read_only image2d_array_t   input,
    int filterX,
    int filterY,
    int strideX,
    int strideY,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    float4 tmpOut = {0.0};
    int i, j, count = 0;

    for(j = 0; j < filterY; j++)
    {
        for(i = 0; i < filterX; i++)
        {
            tmpOut += read_imagef(input, (int4)(x*strideX+i, y*strideY+j, z, 0));
            count++;
        }
    }

    tmpOut.x = tmpOut.x / convert_float(count);

    write_imagef(output, (int4)(x, y, z, 0), tmpOut);
}

__kernel void gpuPooling_AvgNoPadQuant8
    (
    __read_only image2d_array_t   input,
    int   filterX,
    int   filterY,
    int   strideX,
    int   strideY,
    float scaleIn,
    float scaleOut,
    int   zeroPointIn,
    int   zeroPointOut,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    float4 tmpOut = {0.0};
    int i, j, count = 0;
    uint4 tmp;

    for(j = 0; j < filterY; j++)
    {
        for(i = 0; i < filterX; i++)
        {
            tmp = read_imageui(input, (int4)(x * strideX + i, y * strideY + j, z, 0));
            tmpOut.x += (convert_int(tmp.x - zeroPointIn)) * scaleIn;
            count++;
        }
    }

    tmpOut.x = tmpOut.x / convert_float(count);
    tmp.x = floor(tmpOut.x * scaleOut + zeroPointOut + 0.5);

    write_imageui(output, (int4)(x, y, z, 0), tmp);
}

__kernel void gpuPooling_AvgPadFP32
    (
    __read_only image2d_array_t   input,
    int filterX,
    int filterY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    int enable_tf,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int coordinX = x*strideX - padX;
    int coordinY = y*strideY - padY;
    int z = get_global_id(2);
    float4 tmpOut = {0.0};
    int inWidth = get_image_width(input);
    int inHeight = get_image_height(input);
    int iStart, iEnd, jStart, jEnd, count = 0;
    int w, h;

    iStart = max(coordinX, 0);
    iEnd   = min(coordinX+filterX, inWidth);
    jStart = max(coordinY, 0);
    jEnd   = min(coordinY+filterY, inHeight);

    for(h = jStart; h < jEnd; h++)
    {
        for(w = iStart; w < iEnd; w++)
        {
            tmpOut += read_imagef(input, (int4)(w, h, z, 0));
            count++;
        }
    }

    if (enable_tf)
    {
        tmpOut.x = tmpOut.x / convert_float(count);
    }
    else
    {
        tmpOut.x = tmpOut.x / convert_float(filterX * filterY);
    }

    write_imagef(output, (int4)(x, y, z, 0), tmpOut);
}

__kernel void gpuPooling_AvgPadQuant8
    (
    __read_only image2d_array_t   input,
    int   filterX,
    int   filterY,
    int   strideX,
    int   strideY,
    float scaleIn,
    float scaleOut,
    int   zeroPointIn,
    int   zeroPointOut,
    int   padX,
    int   padY,
    int   enable_tf,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int coordinX = x*strideX - padX;
    int coordinY = y*strideY - padY;
    float4 tmpOut = {0.0};
    int inWidth = get_image_width(input);
    int inHeight = get_image_height(input);
    int iStart, iEnd, jStart, jEnd, count = 0;
    int w, h;
    uint4 tmp;

    iStart = max(coordinX, 0);
    iEnd   = min(coordinX+filterX, inWidth);
    jStart = max(coordinY, 0);
    jEnd   = min(coordinY+filterY, inHeight);

    for(h = jStart; h < jEnd; h++)
    {
        for(w = iStart; w < iEnd; w++)
        {
            tmp = read_imageui(input, (int4)(w, h, z, 0));
            tmpOut.x += (convert_int(tmp.x - zeroPointIn)) * scaleIn;
            count++;
        }
    }
    if (enable_tf)
    {
        tmpOut.x = tmpOut.x / convert_float(count);
    }
    else
    {
        tmpOut.x = tmpOut.x / convert_float(filterX * filterY);
    }
    tmp.x = floor(tmpOut.x * scaleOut + zeroPointOut + 0.5);

    write_imageui(output, (int4)(x, y, z, 0), tmp);
}

__kernel void gpuPooling_AvgNoPadFP32_opt
    (
    __read_only image2d_array_t   input,
    int filterX,
    int filterY,
    int strideX,
    int strideY,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    float4 tmpOut = {0.0};
    int i, j, count = 0;
    float sum = 0;
    int offset = x*strideX;
    float4 one = {1.0, 1.0, 1.0, 1.0};
    float4 data;

    for(j = 0; j < filterY; j++)
    {
        for(i = 0; i < filterX; i+=4)
        {
            data = read_imagef(input, (int4)(offset + i, y * strideY + j, z, 0));
            tmpOut.x += data.x;
            data = read_imagef(input, (int4)(offset + i + 1, y * strideY + j, z, 0));
            tmpOut.y += data.x;
            data = read_imagef(input, (int4)(offset + i + 2, y * strideY + j, z, 0));
            tmpOut.z += data.x;
            data = read_imagef(input, (int4)(offset + i + 3, y * strideY + j, z, 0));
            tmpOut.w += data.x;

            count += 4;
        }
    }
    sum = dot(tmpOut, one);

    tmpOut.x = sum / convert_float(count);

    write_imagef(output, (int4)(x, y, z, 0), tmpOut);
}

__kernel void gpuPooling_AvgNoPadFP32_res1
    (
    __read_only image2d_array_t   input,
    int filterX,
    int filterY,
    int strideX,
    int strideY,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    float4 tmpOut = {0.0}, data = {0.0};
    int i, j, count = 0;
    float sum = 0;

    int iter = (filterX >> 2) << 2;
    int offset1 = x*strideX;
    int offset0 = offset1 + iter;
    float4 one = {1.0, 1.0, 1.0, 1.0};

    for(j = 0; j < filterY; j++)
    {
        for(i = 0; i < iter; i+=4)
        {
            data = read_imagef(input, (int4)(offset1 + i, y * strideY + j, z, 0));
            tmpOut.x += data.x;
            data = read_imagef(input, (int4)(offset1 + i + 1, y * strideY + j, z, 0));
            tmpOut.y += data.x;
            data = read_imagef(input, (int4)(offset1 + i + 2, y * strideY + j, z, 0));
            tmpOut.z += data.x;
            data = read_imagef(input, (int4)(offset1 + i + 3, y * strideY + j, z, 0));
            tmpOut.w += data.x;

            count += 4;
        }
        data = read_imagef(input, (int4)(offset0, y*strideY+j, z, 0));
        sum += data.x;
        count ++;
    }

    sum += dot(tmpOut, one);
    tmpOut.x = sum / convert_float(count);

    write_imagef(output, (int4)(x, y, z, 0), tmpOut);
}

__kernel void gpuPooling_AvgNoPadFP32_res2
    (
    __read_only image2d_array_t   input,
    int filterX,
    int filterY,
    int strideX,
    int strideY,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    float4 tmpOut = {0.0}, data = {0.0};
    int i, j, count = 0;
    float sum = 0;

    int iter = (filterX >> 2) << 2;
    int offset1 = x*strideX;
    int offset0 = offset1 + iter;
    float4 one = {1.0, 1.0, 1.0, 1.0};

    for(j = 0; j < filterY; j++)
    {
        for(i = 0; i < iter; i+=4)
        {
            data = read_imagef(input, (int4)(offset1 + i, y * strideY + j, z, 0));
            tmpOut.x += data.x;
            data = read_imagef(input, (int4)(offset1 + i + 1, y * strideY + j, z, 0));
            tmpOut.y += data.x;
            data = read_imagef(input, (int4)(offset1 + i + 2, y * strideY + j, z, 0));
            tmpOut.z += data.x;
            data = read_imagef(input, (int4)(offset1 + i + 3, y * strideY + j, z, 0));
            tmpOut.w += data.x;

            count+=4;
        }

        data = read_imagef(input, (int4)(offset0, y * strideY + j, z, 0));
        sum += data.x;
        data = read_imagef(input, (int4)(offset0 + 1, y * strideY + j, z, 0));
        sum += data.x;

        count+=2;
    }

    sum += dot(tmpOut, one);
    tmpOut.x = sum / convert_float(count);

    write_imagef(output, (int4)(x, y, z, 0), tmpOut);
}

__kernel void gpuPooling_AvgNoPadFP32_res3
    (
    __read_only image2d_array_t   input,
    int filterX,
    int filterY,
    int strideX,
    int strideY,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    float4 tmpOut = {0.0}, tmpOut1 = {0.0};
    int i, j, count = 0;
    float sum = 0;
    float4 one = {1.0, 1.0, 1.0, 1.0};
    float4 data;

    int iter = (filterX >> 2) << 2;
    int offset1 = x*strideX;
    int offset0 = offset1 + iter;

    for(j = 0; j < filterY; j++)
    {
        for(i = 0; i < iter; i+=4)
        {
            data = read_imagef(input, (int4)(offset1 + i, y * strideY + j, z, 0));
            tmpOut.x += data.x;
            data = read_imagef(input, (int4)(offset1 + i + 1, y * strideY + j, z, 0));
            tmpOut.y += data.x;
            data = read_imagef(input, (int4)(offset1 + i + 2, y * strideY + j, z, 0));
            tmpOut.z += data.x;
            data = read_imagef(input, (int4)(offset1 + i + 3, y * strideY + j, z, 0));
            tmpOut.w += data.x;

            count += 4;
        }

        data = read_imagef(input, (int4)(offset0, y * strideY + j, z, 0));
        tmpOut1.x += data.x;
        data = read_imagef(input, (int4)(offset0 + 1, y * strideY + j, z, 0));
        tmpOut1.y += data.x;
        data = read_imagef(input, (int4)(offset0 + 2, y * strideY + j, z, 0));
        tmpOut1.z += data.x;

        count += 3;
    }

    tmpOut1.w = 0;
    tmpOut += tmpOut1;
    sum = dot(tmpOut, one);
    tmpOut.x = sum / convert_float(count);

    write_imagef(output, (int4)(x, y, z, 0), tmpOut);
}

__kernel void gpuPooling_AvgNoPadQuant8_opt
    (
    __read_only image2d_array_t   input,
    int   filterX,
    int   filterY,
    int   strideX,
    int   strideY,
    float scaleIn,
    float scaleOut,
    int   zeroPointIn,
    int   zeroPointOut,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int i, j, count = 0;
    uint4 tmp = {0}, tmpSum = {0};
    uint sum = 0;
    float tmpOut = 0.0;
    int offset2 = y*strideY;

    for(j = 0; j < filterY; j++)
    {
        int row = offset2 + j;
        for(i = 0; i < filterX; i+=4)
        {
            tmp = read_imageui(input, (int4)(x * strideX + i, row, z, 0));
            tmpSum.x += tmp.x;
            tmp = read_imageui(input, (int4)(x * strideX + i + 1, row, z, 0));
            tmpSum.y += tmp.x;
            tmp = read_imageui(input, (int4)(x * strideX + i + 2, row, z, 0));
            tmpSum.z += tmp.x;
            tmp = read_imageui(input, (int4)(x * strideX + i + 3, row, z, 0));
            tmpSum.w += tmp.x;

            count+=4;
        }
    }
    sum = tmpSum.x + tmpSum.y + tmpSum.z + tmpSum.w;
    tmpOut = convert_int(sum - count * zeroPointIn) * scaleIn;
    tmpOut = tmpOut / convert_float(count);
    tmp.x = floor(tmpOut * scaleOut + zeroPointOut + 0.5);

    write_imageui(output, (int4)(x, y, z, 0), tmp);
}

__kernel void gpuPooling_AvgNoPadQuant8_res1
    (
    __read_only image2d_array_t   input,
    int   filterX,
    int   filterY,
    int   strideX,
    int   strideY,
    float scaleIn,
    float scaleOut,
    int   zeroPointIn,
    int   zeroPointOut,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    float4 tmpOut = {0.0};
    int i, j, count = 0;
    uint4 tmp, tmpSum = {0};
    int iter = (filterX >> 2) << 2;
    uint tmpSum1 = 0;
    uint sum = 0;

    int offset1 = x*strideX;
    int offset0 = offset1 + iter;
    int offset2 = y*strideY;

    for(j = 0; j < filterY; j++)
    {
        int row = offset2 + j;
        for(i = 0; i < iter; i+=4)
        {
            tmp = read_imageui(input, (int4)(offset1 + i, row, z, 0));
            tmpSum.x += tmp.x;
            tmp = read_imageui(input, (int4)(offset1 + i + 1, row, z, 0));
            tmpSum.y += tmp.x;
            tmp = read_imageui(input, (int4)(offset1 + i + 2, row, z, 0));
            tmpSum.z += tmp.x;
            tmp = read_imageui(input, (int4)(offset1 + i + 3, row, z, 0));
            tmpSum.w += tmp.x;

            count+=4;
        }
        tmp = read_imageui(input, (int4)(offset0, row, z, 0));
        tmpSum1 += tmp.x;
        count++;
    }
    sum = tmpSum.x + tmpSum.y + tmpSum.z + tmpSum.w + tmpSum1;
    tmpOut.x = convert_int(sum - count * zeroPointIn) * scaleIn;
    tmpOut.x = tmpOut.x / convert_float(count);
    tmp.x = floor(tmpOut.x * scaleOut + zeroPointOut + 0.5);

    write_imageui(output, (int4)(x, y, z, 0), tmp);
}

__kernel void gpuPooling_AvgNoPadQuant8_res2
    (
    __read_only image2d_array_t   input,
    int   filterX,
    int   filterY,
    int   strideX,
    int   strideY,
    float scaleIn,
    float scaleOut,
    int   zeroPointIn,
    int   zeroPointOut,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    float4 tmpOut = {0.0};
    int i, j, count = 0;
    uint4 tmp = {0}, tmpSum = {0}, data;
    int iter = (filterX >> 2) << 2;
    uint tmpSum1 = 0;
    uint sum = 0;

    int offset1 = x*strideX;
    int offset0 = offset1 + iter;
    int offset2 = y*strideY;

    for(j = 0; j < filterY; j++)
    {
        int row = offset2 + j;
        for(i = 0; i < iter; i+=4)
        {
            tmp = read_imageui(input, (int4)(offset1 + i, row, z, 0));
            tmpSum.x += tmp.x;
            tmp = read_imageui(input, (int4)(offset1 + i + 1, row, z, 0));
            tmpSum.y += tmp.x;
            tmp = read_imageui(input, (int4)(offset1 + i + 2, row, z, 0));
            tmpSum.z += tmp.x;
            tmp = read_imageui(input, (int4)(offset1 + i + 3, row, z, 0));
            tmpSum.w += tmp.x;

            count+=4;
        }
        tmp = read_imageui(input, (int4)(offset0, row, z, 0));
        tmpSum1 += tmp.x;
        tmp = read_imageui(input, (int4)(offset0 + 1, row, z, 0));
        tmpSum1 += tmp.x;

        count+=2;
    }
    sum = tmpSum.x + tmpSum.y + tmpSum.z + tmpSum.w + tmpSum1;
    tmpOut.x = convert_int(sum - count * zeroPointIn) * scaleIn;
    tmpOut.x = tmpOut.x / convert_float(count);
    tmp.x = floor(tmpOut.x * scaleOut + zeroPointOut + 0.5);

    write_imageui(output, (int4)(x, y, z, 0), tmp);
}

__kernel void gpuPooling_AvgNoPadQuant8_res3
    (
    __read_only image2d_array_t   input,
    int   filterX,
    int   filterY,
    int   strideX,
    int   strideY,
    float scaleIn,
    float scaleOut,
    int   zeroPointIn,
    int   zeroPointOut,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    float4 tmpOut = {0.0};
    int i, j, count = 0;
    uint4 tmp, tmpSum = {0};
    int iter = (filterX >> 2) << 2;
    uint4 tmpSum1 = {0};
    uint sum = 0;

    int offset1 = x*strideX;
    int offset0 = offset1 + iter;
    int offset2 = y*strideY;

    for(j = 0; j < filterY; j++)
    {
        int row = offset2 + j;
        for(i = 0; i < iter; i+=4)
        {
            tmp = read_imageui(input, (int4)(offset1 + i, row, z, 0));
            tmpSum.x += tmp.x;
            tmp = read_imageui(input, (int4)(offset1 + i + 1, row, z, 0));
            tmpSum.y += tmp.x;
            tmp = read_imageui(input, (int4)(offset1 + i + 2, row, z, 0));
            tmpSum.z += tmp.x;
            tmp = read_imageui(input, (int4)(offset1 + i + 3, row, z, 0));
            tmpSum.w += tmp.x;

            count+=4;
        }
        tmp = read_imageui(input, (int4)(offset0, row, z, 0));
        tmpSum1.x += tmp.x;
        tmp = read_imageui(input, (int4)(offset0 + 1, row, z, 0));
        tmpSum1.y += tmp.x;
        tmp = read_imageui(input, (int4)(offset0 + 2, row, z, 0));
        tmpSum1.z += tmp.x;

        count+=3;
    }

    tmpSum1.w = 0;
    tmpSum += tmpSum1;
    sum = tmpSum.x + tmpSum.y + tmpSum.z + tmpSum.w;
    tmpOut.x = convert_int(sum - count * zeroPointIn) * scaleIn;
    tmpOut.x = tmpOut.x / convert_float(count);
    tmp.x = floor(tmpOut.x * scaleOut + zeroPointOut + 0.5);

    write_imageui(output, (int4)(x, y, z, 0), tmp);
}

__kernel void gpuPooling_AvgNoPadQuant8_7x7
    (
    __read_only image2d_array_t   input,
    int   filterX,
    int   filterY,
    int   strideX,
    int   strideY,
    float scaleIn,
    float scaleOut,
    int   zeroPointIn,
    int   zeroPointOut,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    float4 tmpOut = {0.0};
    int j;
    uint4 tmp, tmpSum = {0};
    uint4 tmpSum1 = {0};
    uint4 tmp0;
    uint sum = 0;

    int offset1 = x*strideX;
    int offset0 = offset1 + 4;
    int offset2 = y*strideY;
    float constVal = 49.0;

    for(j = 0; j < 7; j++)
    {
        int row = offset2 + j;
        tmp0 = read_imageui(input, (int4)(offset1, row, z, 0));
        tmpSum.x += tmp0.x;
        tmp0 = read_imageui(input, (int4)(offset1 + 1, row, z, 0));
        tmpSum.y += tmp0.x;
        tmp0 = read_imageui(input, (int4)(offset1 + 2, row, z, 0));
        tmpSum.z += tmp0.x;
        tmp0 = read_imageui(input, (int4)(offset1 + 3, row, z, 0));
        tmpSum.w += tmp0.x;

        tmp0 = read_imageui(input, (int4)(offset0, row, z, 0));
        tmpSum1.x += tmp0.x;
        tmp0 = read_imageui(input, (int4)(offset0 + 1, row, z, 0));
        tmpSum1.y += tmp0.x;
        tmp0 = read_imageui(input, (int4)(offset0 + 2, row, z, 0));
        tmpSum1.z += tmp0.x;
    }

    tmpSum1.w = 0;
    tmpSum += tmpSum1;
    sum = tmpSum.x + tmpSum.y + tmpSum.z + tmpSum.w;
    tmpOut.x = convert_int(sum - 49 * zeroPointIn) * scaleIn;
    tmpOut.x = tmpOut.x / constVal;
    tmp.x = floor(tmpOut.x * scaleOut + zeroPointOut + 0.5);

    write_imageui(output, (int4)(x, y, z, 0), tmp);
}

__kernel void gpuPooling_AvgPadFP32_opt
    (
    __read_only image2d_array_t   input,
    int filterX,
    int filterY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    int enable_tf,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int coordinX = x*strideX - padX;
    int coordinY = y*strideY - padY;
    int z = get_global_id(2);
    float4 tmp0;
    float4 tmpOut = {0.0};
    int inWidth = get_image_width(input);
    int inHeight = get_image_height(input);
    int iStart, iEnd, jStart, jEnd, count = 0;
    int w, h;

    iStart = max(coordinX, 0);
    iEnd   = min(coordinX+filterX, inWidth);
    jStart = max(coordinY, 0);
    jEnd   = min(coordinY+filterY, inHeight);

    float sum = 0;
    int len = iEnd - iStart;
    int iter = (len >> 2) << 2;
    int offset = iStart + iter;
    float4 data = {0.0};

    for(h = jStart; h < jEnd; h++)
    {
        for(w = iStart; w < offset; w+=4)
        {
            tmp0 = read_imagef(input, (int4)(w, h, z, 0));
            tmpOut.x += tmp0.x;
            tmp0 = read_imagef(input, (int4)(w + 1, h, z, 0));
            tmpOut.y += tmp0.x;
            tmp0 = read_imagef(input, (int4)(w + 2, h, z, 0));
            tmpOut.z += tmp0.x;
            tmp0 = read_imagef(input, (int4)(w + 3, h, z, 0));
            tmpOut.w += tmp0.x;

            count+=4;
        }
        for(w = offset; w < iEnd; w++)
        {
            data = read_imagef(input, (int4)(w, h, z, 0));
            sum += data.x;
            count++;
        }
    }
    sum += tmpOut.x + tmpOut.y + tmpOut.z + tmpOut.w;
    if (enable_tf)
    {
        tmpOut.x = sum / convert_float(count);
    }
    else
    {
        tmpOut.x = sum / convert_float(filterX * filterY);
    }

    write_imagef(output, (int4)(x, y, z, 0), tmpOut);
}

__kernel void gpuPooling_AvgPadQuant8_opt
    (
    __read_only image2d_array_t   input,
    int   filterX,
    int   filterY,
    int   strideX,
    int   strideY,
    float scaleIn,
    float scaleOut,
    int   zeroPointIn,
    int   zeroPointOut,
    int   padX,
    int   padY,
    int   enable_tf,
    __write_only image2d_array_t  output
    )
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int coordinX = x*strideX - padX;
    int coordinY = y*strideY - padY;
    float4 tmpOut = {0.0};
    int inWidth = get_image_width(input);
    int inHeight = get_image_height(input);
    int iStart, iEnd, jStart, jEnd, count = 0;
    int w, h;
    uint4 tmp = {0}, data;

    iStart = max(coordinX, 0);
    iEnd   = min(coordinX+filterX, inWidth);
    jStart = max(coordinY, 0);
    jEnd   = min(coordinY+filterY, inHeight);

    int len = iEnd - iStart;
    int iter = (len >> 2) << 2;
    uint tmpSum = 0;
    int offset = iStart + iter;

    for(h = jStart; h < jEnd; h++)
    {
        for(w = iStart; w < offset; w+=4)
        {
            data = read_imageui(input, (int4)(w, h, z, 0));
            tmp.x += data.x;
            data = read_imageui(input, (int4)(w + 1, h, z, 0));
            tmp.y += data.x;
            data = read_imageui(input, (int4)(w + 2, h, z, 0));
            tmp.z += data.x;
            data = read_imageui(input, (int4)(w + 3, h, z, 0));
            tmp.w += data.x;

            count+=4;
        }
        for(w = offset; w < iEnd; w++)
        {
            data = read_imageui(input, (int4)(w, h, z, 0));
            tmpSum += data.x;
            count++;
        }
    }

    tmpSum += tmp.x + tmp.y + tmp.z + tmp.w;
    tmpOut.x = convert_int(tmpSum - count * zeroPointIn) * scaleIn;
    if (enable_tf)
    {
        tmpOut.x = tmpOut.x / convert_float(count);
    }
    else
    {
        tmpOut.x = tmpOut.x / convert_float(filterX * filterY);
    }

    tmp.x = floor(tmpOut.x * scaleOut + zeroPointOut + 0.5);

    write_imageui(output, (int4)(x, y, z, 0), tmp);
}

typedef _viv_uchar16_packed   vxc_uchar16;
typedef _viv_ushort8_packed   vxc_ushort8;

float4 calculate_avg_scale4(const int pool_size, const int upper_bound_w, const int upper_bound_h,
                     const int pad_x, const int pad_y, const int stride_x, const int stride_y)
{
    int4       start_x = ((int4)get_global_id(0) + (int4)(0, 1, 2, 3)) * (int4)stride_x - (int4)pad_x;
    int        start_y = get_global_id(1) * stride_y - pad_y;
    const int4 end_x   = min(start_x + (int4)pool_size, (int4)upper_bound_w);
    const int  end_y   = min(start_y + pool_size, upper_bound_h);

    start_x = max((int4)0, start_x);
    start_y = max(0, start_y);

    return ((float4)(1.f) / convert_float4(((int4)(end_y - start_y)) * (end_x - start_x)));
}

__kernel void gpuPooling_AvgNoPadQuant8_K3S1_M1_2D
    (
    __read_only  image2d_t        input,
    __write_only image2d_t        output,
    int                           inputWidth,
    int                           inputHeight,
    int                           inputHeightPad,
    int                           pad_left,
    int                           pad_top,
    int                           stride_y,
    int                           outputHeight,
    float                         input_scale,
    float                         input_tail,
    float                         output_scale,
    float                         output_zp,
    int                           enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0), get_global_id(1) * stride_y + coord.z * inputHeightPad, get_global_id(0), get_global_id(0));

    //coord_in.zw = coord_in.xy + (int2)(4, 1);

    Image in_tensor = create_image_from_image2d(input, 1);
    int strideX = in_tensor.stride_y;
    uchar *src_ptr = get_image_ptr_from_coord(in_tensor, coord_in.xy);
    uchar *src_ptr_line0 = src_ptr;
    uchar *src_ptr_line1 = src_ptr_line0 + strideX;
    uchar *src_ptr_line2 = src_ptr_line1 + strideX;

    vxc_uchar16 src0 = vload16(0, (_viv_uchar_packed *)src_ptr_line0);
    vxc_uchar16 src1 = vload16(0, (_viv_uchar_packed *)src_ptr_line1);
    vxc_uchar16 src2 = vload16(0, (_viv_uchar_packed *)src_ptr_line2);

    coord.y = coord.z * outputHeight + coord.y;
    coord.zw = coord.xx + (int2)(1, 2);
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 1, stride_y);

    vxc_ushort8 src0_u16, src1_u16, src2_u16;
    vxc_ushort8 data00, data10, data20;
    src0 = src0.s08192a3b4c5d6e7f;
    src1 = src1.s08192a3b4c5d6e7f;
    src2 = src2.s08192a3b4c5d6e7f;
    vxc_ushort8 bits = (vxc_ushort8)(8, 8, 8, 8, 8, 8, 8, 8);
    vxc_ushort8 cfg =  (vxc_ushort8)(0, 0, 0, 0, 0, 0, 0, 0);

    _viv_asm(COPY, src0_u16, src0, 16);
    _viv_asm(COPY, src1_u16, src1, 16);
    _viv_asm(COPY, src2_u16, src2, 16);
    data00 = viv_bitfieldExtract(src0_u16, cfg, bits);
    data10 = viv_bitfieldExtract(src1_u16, cfg, bits);
    data20 = viv_bitfieldExtract(src2_u16, cfg, bits);

    vxc_ushort8 value00 = data00 + data10 + data20;

    value00 = value00 + value00.s12345670 + value00.s23456701;

    uint4 bits1 = (uint4)(16, 16, 16, 16);
    uint4 cfg1 = (uint4)(0, 16, 0, 16);
    uint4 src;

    _viv_asm(COPY, src, value00, 16);
    uint4 result = viv_bitfieldExtract(src.xxyy, cfg1, bits1);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }

    result = convert_uint4((convert_float4(result) * input_scale - (float4)input_tail) * (float4) scale * (float4) output_scale + output_zp);

    write_imageui(output, coord.xy, result.xxxx);
    coord.x += 3;
    write_imageui(output, coord.zy, result.yyyy);
    write_imageui(output, coord.wy, result.zzzz);
    write_imageui(output, coord.xy, result.wwww);
}

__kernel void gpuPooling_AvgNoPadQuant8_K3S1_M2_2D
    (
    __read_only  image2d_t        input,
    __write_only image2d_t        output,
    int                           inputWidth,
    int                           inputHeight,
    int                           inputHeightPad,
    int                           pad_left,
    int                           pad_top,
    int                           stride_y,
    int                           outputHeight,
    float                         input_scale,
    float                         input_tail,
    float                         output_scale,
    float                         output_zp,
    int                           enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0), get_global_id(1) * stride_y + coord.z * inputHeightPad, get_global_id(0), get_global_id(0));

    //coord_in.zw = coord_in.xy + (int2)(4, 1);

    Image in_tensor = create_image_from_image2d(input, 1);
    int strideX = in_tensor.stride_y;
    uchar *src_ptr = get_image_ptr_from_coord(in_tensor, coord_in.xy);
    uchar *src_ptr_line0 = src_ptr;
    uchar *src_ptr_line1 = src_ptr_line0 + strideX;
    uchar *src_ptr_line2 = src_ptr_line1 + strideX;

    vxc_uchar16 src0 = vload16(0, (_viv_uchar_packed *)src_ptr_line0);
    vxc_uchar16 src1 = vload16(0, (_viv_uchar_packed *)src_ptr_line1);
    vxc_uchar16 src2 = vload16(0, (_viv_uchar_packed *)src_ptr_line2);

    coord.y = coord.z * outputHeight + coord.y;
    coord.x >>= 1;
    coord.zw = coord.xx + (int2)(1, 2);
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 1, stride_y);

    vxc_ushort8 src0_u16, src1_u16, src2_u16;
    vxc_ushort8 data00, data10, data20;
    src0 = src0.s08192a3b4c5d6e7f;
    src1 = src1.s08192a3b4c5d6e7f;
    src2 = src2.s08192a3b4c5d6e7f;
    vxc_ushort8 bits = (vxc_ushort8)(8, 8, 8, 8, 8, 8, 8, 8);
    vxc_ushort8 cfg =  (vxc_ushort8)(0, 0, 0, 0, 0, 0, 0, 0);

    _viv_asm(COPY, src0_u16, src0, 16);
    _viv_asm(COPY, src1_u16, src1, 16);
    _viv_asm(COPY, src2_u16, src2, 16);
    data00 = viv_bitfieldExtract(src0_u16, cfg, bits);
    data10 = viv_bitfieldExtract(src1_u16, cfg, bits);
    data20 = viv_bitfieldExtract(src2_u16, cfg, bits);

    vxc_ushort8 value00 = data00 + data10 + data20;

    value00 = value00 + value00.s12345670 + value00.s23456701;

    uint4 bits1 = (uint4)(16, 16, 16, 16);
    uint4 cfg1 = (uint4)(0, 16, 0, 16);
    uint4 src;

    _viv_asm(COPY, src, value00, 16);
    uint4 result = viv_bitfieldExtract(src.xxyy, cfg1, bits1);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }

    result = convert_uint4((convert_float4(result) * input_scale - (float4)input_tail) * (float4) scale * (float4) output_scale + output_zp);

    write_imageui(output, coord.xy, result.xyxy);
    write_imageui(output, coord.zy, result.zwzw);
}

__kernel void gpuPooling_AvgNoPadQuant8_K3S1_M4_2D
    (
    __read_only  image2d_t        input,
    __write_only image2d_t        output,
    int                           inputWidth,
    int                           inputHeight,
    int                           inputHeightPad,
    int                           pad_left,
    int                           pad_top,
    int                           stride_y,
    int                           outputHeight,
    float                         input_scale,
    float                         input_tail,
    float                         output_scale,
    float                         output_zp,
    int                           enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0), get_global_id(1) * stride_y + coord.z * inputHeightPad, get_global_id(0), get_global_id(0));

    Image in_tensor = create_image_from_image2d(input, 1);
    int strideX = in_tensor.stride_y;
    uchar *src_ptr = get_image_ptr_from_coord(in_tensor, coord_in.xy);
    uchar *src_ptr_line0 = src_ptr;
    uchar *src_ptr_line1 = src_ptr_line0 + strideX;
    uchar *src_ptr_line2 = src_ptr_line1 + strideX;

    vxc_uchar16 src0 = vload16(0, (_viv_uchar_packed *)src_ptr_line0);
    vxc_uchar16 src1 = vload16(0, (_viv_uchar_packed *)src_ptr_line1);
    vxc_uchar16 src2 = vload16(0, (_viv_uchar_packed *)src_ptr_line2);

    coord.y = coord.z * outputHeight + coord.y;
    coord.x >>= 2;
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 1, stride_y);

    vxc_ushort8 src0_u16, src1_u16, src2_u16;
    vxc_ushort8 data00, data10, data20;
    src0 = src0.s08192a3b4c5d6e7f;
    src1 = src1.s08192a3b4c5d6e7f;
    src2 = src2.s08192a3b4c5d6e7f;
    vxc_ushort8 bits = (vxc_ushort8)(8, 8, 8, 8, 8, 8, 8, 8);
    vxc_ushort8 cfg =  (vxc_ushort8)(0, 0, 0, 0, 0, 0, 0, 0);

    _viv_asm(COPY, src0_u16, src0, 16);
    _viv_asm(COPY, src1_u16, src1, 16);
    _viv_asm(COPY, src2_u16, src2, 16);
    data00 = viv_bitfieldExtract(src0_u16, cfg, bits);
    data10 = viv_bitfieldExtract(src1_u16, cfg, bits);
    data20 = viv_bitfieldExtract(src2_u16, cfg, bits);

    vxc_ushort8 value00 = data00 + data10 + data20;

    value00 = value00 + value00.s12345670 + value00.s23456701;

    uint4 bits1 = (uint4)(16, 16, 16, 16);
    uint4 cfg1 = (uint4)(0, 16, 0, 16);
    uint4 src;

    _viv_asm(COPY, src, value00, 16);
    uint4 result = viv_bitfieldExtract(src.xxyy, cfg1, bits1);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }

    result = convert_uint4((convert_float4(result) * input_scale - (float4)input_tail) * (float4) scale * (float4) output_scale + output_zp);

    write_imageui(output, coord.xy, result);
}

__kernel void gpuPooling_AvgNoPadQuant8_K3S2_M1_2D
    (
    __read_only  image2d_t        input,
    __write_only image2d_t        output,
    int                           inputWidth,
    int                           inputHeight,
    int                           inputHeightPad,
    int                           pad_left,
    int                           pad_top,
    int                           stride_y,
    int                           outputHeight,
    float                         input_scale,
    float                         input_tail,
    float                         output_scale,
    float                         output_zp,
    int                           enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0) << 1, (get_global_id(1) * stride_y) + coord.z * inputHeightPad, get_global_id(0), get_global_id(0));

    Image in_tensor = create_image_from_image2d(input, 1);
    int strideX = in_tensor.stride_y;
    uchar *src_ptr = get_image_ptr_from_coord(in_tensor, coord_in.xy);
    uchar *src_ptr_line0 = src_ptr;
    uchar *src_ptr_line1 = src_ptr_line0 + strideX;
    uchar *src_ptr_line2 = src_ptr_line1 + strideX;

    vxc_uchar16 src0 = vload16(0, (_viv_uchar_packed *)src_ptr_line0);
    vxc_uchar16 src1 = vload16(0, (_viv_uchar_packed *)src_ptr_line1);
    vxc_uchar16 src2 = vload16(0, (_viv_uchar_packed *)src_ptr_line2);

    coord.y = coord.z * outputHeight + coord.y;
    coord.zw = coord.xx + (int2)(1, 2);
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 2, stride_y);

    vxc_ushort8 src0_u16, src1_u16, src2_u16;
    vxc_ushort8 data00, data10, data20;
    vxc_ushort8 data01, data11, data21;
    src0 = src0.s08192a3b4c5d6e7f;
    src1 = src1.s08192a3b4c5d6e7f;
    src2 = src2.s08192a3b4c5d6e7f;
    vxc_ushort8 bits = (vxc_ushort8)(8, 8, 8, 8, 8, 8, 8, 8);
    vxc_ushort8 cfg =  (vxc_ushort8)(0, 0, 0, 0, 0, 0, 0, 0);

    _viv_asm(COPY, src0_u16, src0, 16);
    _viv_asm(COPY, src1_u16, src1, 16);
    _viv_asm(COPY, src2_u16, src2, 16);
    data00 = viv_bitfieldExtract(src0_u16, cfg, bits);
    data10 = viv_bitfieldExtract(src1_u16, cfg, bits);
    data20 = viv_bitfieldExtract(src2_u16, cfg, bits);
    data01 = viv_bitfieldExtract(src0_u16, bits, bits);
    data11 = viv_bitfieldExtract(src1_u16, bits, bits);
    data21 = viv_bitfieldExtract(src2_u16, bits, bits);

    vxc_ushort8 value00 = data00 + data10 + data20;
    vxc_ushort8 value01 = data01 + data11 + data21;

    value01 = (vxc_ushort8)(value00.s2, value00.s4, value00.s6, value01.s0, value01.s1, value01.s2, value01.s3, value01.s4);
    value00 = value00.s02461357 + value00.s13570246 + value01;

    uint4 bits1 = (uint4)(16, 16, 16, 16);
    uint4 cfg1 = (uint4)(0, 16, 0, 16);
    uint4 src;

    _viv_asm(COPY, src, value00, 16);
    uint4 result = viv_bitfieldExtract(src.xxyy, cfg1, bits1);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }

    result = convert_uint4((convert_float4(result) * input_scale - (float4)input_tail) * (float4) scale * (float4) output_scale + output_zp);

    write_imageui(output, coord.xy, result.xxxx);
    coord.x += 3;
    write_imageui(output, coord.zy, result.yyyy);
    write_imageui(output, coord.wy, result.zzzz);
    write_imageui(output, coord.xy, result.wwww);
}


__kernel void gpuPooling_AvgNoPadQuant8_K3S2_M2_2D
    (
    __read_only  image2d_t        input,
    __write_only image2d_t        output,
    int                           inputWidth,
    int                           inputHeight,
    int                           inputHeightPad,
    int                           pad_left,
    int                           pad_top,
    int                           stride_y,
    int                           outputHeight,
    float                         input_scale,
    float                         input_tail,
    float                         output_scale,
    float                         output_zp,
    int                           enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0) << 1, (get_global_id(1) * stride_y) + coord.z * inputHeightPad, get_global_id(0), get_global_id(0));

    Image in_tensor = create_image_from_image2d(input, 1);
    int strideX = in_tensor.stride_y;
    uchar *src_ptr = get_image_ptr_from_coord(in_tensor, coord_in.xy);
    uchar *src_ptr_line0 = src_ptr;
    uchar *src_ptr_line1 = src_ptr_line0 + strideX;
    uchar *src_ptr_line2 = src_ptr_line1 + strideX;

    vxc_uchar16 src0 = vload16(0, (_viv_uchar_packed *)src_ptr_line0);
    vxc_uchar16 src1 = vload16(0, (_viv_uchar_packed *)src_ptr_line1);
    vxc_uchar16 src2 = vload16(0, (_viv_uchar_packed *)src_ptr_line2);

    coord.y = coord.z * outputHeight + coord.y;
    coord.x >>= 2;
    coord.zw = coord.xx + (int2)(1, 2);
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 2, stride_y);

    vxc_ushort8 src0_u16, src1_u16, src2_u16;
    vxc_ushort8 data00, data10, data20;
    vxc_ushort8 data01, data11, data21;
    src0 = src0.s08192a3b4c5d6e7f;
    src1 = src1.s08192a3b4c5d6e7f;
    src2 = src2.s08192a3b4c5d6e7f;
    vxc_ushort8 bits = (vxc_ushort8)(8, 8, 8, 8, 8, 8, 8, 8);
    vxc_ushort8 cfg =  (vxc_ushort8)(0, 0, 0, 0, 0, 0, 0, 0);

    _viv_asm(COPY, src0_u16, src0, 16);
    _viv_asm(COPY, src1_u16, src1, 16);
    _viv_asm(COPY, src2_u16, src2, 16);
    data00 = viv_bitfieldExtract(src0_u16, cfg, bits);
    data10 = viv_bitfieldExtract(src1_u16, cfg, bits);
    data20 = viv_bitfieldExtract(src2_u16, cfg, bits);
    data01 = viv_bitfieldExtract(src0_u16, bits, bits);
    data11 = viv_bitfieldExtract(src1_u16, bits, bits);
    data21 = viv_bitfieldExtract(src2_u16, bits, bits);

    vxc_ushort8 value00 = data00 + data10 + data20;
    vxc_ushort8 value01 = data01 + data11 + data21;

    value01 = (vxc_ushort8)(value00.s2, value00.s4, value00.s6, value01.s0, value01.s1, value01.s2, value01.s3, value01.s4);
    value00 = value00.s02461357 + value00.s13570246 + value01;

    uint4 bits1 = (uint4)(16, 16, 16, 16);
    uint4 cfg1 = (uint4)(0, 16, 0, 16);
    uint4 src;

    _viv_asm(COPY, src, value00, 16);
    uint4 result = viv_bitfieldExtract(src.xxyy, cfg1, bits1);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }

    result = convert_uint4((convert_float4(result) * input_scale - (float4)input_tail) * (float4) scale * (float4) output_scale + output_zp);

    write_imageui(output, coord.xy, result.xyxy);
    write_imageui(output, coord.zy, result.zwzw);
}


__kernel void gpuPooling_AvgNoPadQuant8_K3S2_M4_2D
    (
    __read_only  image2d_t        input,
    __write_only image2d_t        output,
    int                           inputWidth,
    int                           inputHeight,
    int                           inputHeightPad,
    int                           pad_left,
    int                           pad_top,
    int                           stride_y,
    int                           outputHeight,
    float                         input_scale,
    float                         input_tail,
    float                         output_scale,
    float                         output_zp,
    int                           enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0) << 1, (get_global_id(1) * stride_y) + coord.z * inputHeightPad, get_global_id(0), get_global_id(0));

    Image in_tensor = create_image_from_image2d(input, 1);
    int strideX = in_tensor.stride_y;
    uchar *src_ptr = get_image_ptr_from_coord(in_tensor, coord_in.xy);
    uchar *src_ptr_line0 = src_ptr;
    uchar *src_ptr_line1 = src_ptr_line0 + strideX;
    uchar *src_ptr_line2 = src_ptr_line1 + strideX;

    vxc_uchar16 src0 = vload16(0, (_viv_uchar_packed *)src_ptr_line0);
    vxc_uchar16 src1 = vload16(0, (_viv_uchar_packed *)src_ptr_line1);
    vxc_uchar16 src2 = vload16(0, (_viv_uchar_packed *)src_ptr_line2);

    coord.x >>= 2;
    coord.y = coord.z * outputHeight + coord.y;
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 2, stride_y);

    vxc_ushort8 src0_u16, src1_u16, src2_u16;
    vxc_ushort8 data00, data10, data20;
    vxc_ushort8 data01, data11, data21;
    src0 = src0.s08192a3b4c5d6e7f;
    src1 = src1.s08192a3b4c5d6e7f;
    src2 = src2.s08192a3b4c5d6e7f;
    vxc_ushort8 bits = (vxc_ushort8)(8, 8, 8, 8, 8, 8, 8, 8);
    vxc_ushort8 cfg =  (vxc_ushort8)(0, 0, 0, 0, 0, 0, 0, 0);

    _viv_asm(COPY, src0_u16, src0, 16);
    _viv_asm(COPY, src1_u16, src1, 16);
    _viv_asm(COPY, src2_u16, src2, 16);
    data00 = viv_bitfieldExtract(src0_u16, cfg, bits);
    data10 = viv_bitfieldExtract(src1_u16, cfg, bits);
    data20 = viv_bitfieldExtract(src2_u16, cfg, bits);
    data01 = viv_bitfieldExtract(src0_u16, bits, bits);
    data11 = viv_bitfieldExtract(src1_u16, bits, bits);
    data21 = viv_bitfieldExtract(src2_u16, bits, bits);

    vxc_ushort8 value00 = data00 + data10 + data20;
    vxc_ushort8 value01 = data01 + data11 + data21;

    value01 = (vxc_ushort8)(value00.s2, value00.s4, value00.s6, value01.s0, value01.s1, value01.s2, value01.s3, value01.s4);
    value00 = value00.s02461357 + value00.s13570246 + value01;

    uint4 bits1 = (uint4)(16, 16, 16, 16);
    uint4 cfg1 = (uint4)(0, 16, 0, 16);
    uint4 src;

    _viv_asm(COPY, src, value00, 16);
    uint4 result = viv_bitfieldExtract(src.xxyy, cfg1, bits1);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }

    result = convert_uint4((convert_float4(result) * input_scale - (float4)input_tail) * (float4) scale * (float4) output_scale + output_zp);

    write_imageui(output, coord.xy, result);
}

__kernel void gpuPooling_AvgNoPadFP32_K3S1_M1_2D
    (
    __read_only  image2d_t  input,
    __write_only image2d_t  output,
    int                     inputWidth,
    int                     inputHeight,
    int                     inputHeightPad,
    int                     pad_left,
    int                     pad_top,
    int                     stride_y,
    int                     outputHeight,
    int                     enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0) >> 2, get_global_id(1) * stride_y + coord.z * inputHeightPad, get_global_id(0) >> 2, get_global_id(0) >> 2);

    float4 src00 = read_imagef(input, coord_in.xy);
    coord_in.zw = coord_in.xy + (int2)(1, 1);
    float4 src01 = read_imagef(input, coord_in.zy);
    float4 src10 = read_imagef(input, coord_in.xw);
    float4 src11 = read_imagef(input, coord_in.zw);
    coord_in.y += 2;
    float4 src20 = read_imagef(input, coord_in.xy);
    float4 src21 = read_imagef(input, coord_in.zy);

    coord.y = coord.z * outputHeight + coord.y;
    coord.zw = coord.xx + (int2)(1, 2);
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 1, stride_y);

    float8 data00 = src00.xyzyzwzw;
    float4 data01 = (float4)(src01.x, src00.w, src01.x, src01.y);
    float8 data10 = src10.xyzyzwzw;
    float4 data11 = (float4)(src11.x, src10.w, src11.x, src11.y);
    float8 data20 = src20.xyzyzwzw;
    float4 data21 = (float4)(src21.x, src20.w, src21.x, src21.y);

    data00 += data10;
    data01 += data11;
    data00 += data20;
    data01 += data21;

    float4 result = (float4)(data00.s0, data00.s3, data00.s6, data01.y) + (float4)(data00.s1, data00.s4, data00.s7, data01.z);
    result += (float4)(data00.s2, data00.s5, data01.x, data01.w);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }
    result *= scale;

    write_imagef(output, coord.xy, result.xxxx);
    coord.x += 3;
    write_imagef(output, coord.zy, result.yyyy);
    write_imagef(output, coord.wy, result.zzzz);
    write_imagef(output, coord.xy, result.wwww);
}

__kernel void gpuPooling_AvgNoPadFP32_K3S1_M2_2D
    (
    __read_only  image2d_t  input,
    __write_only image2d_t  output,
    int                     inputWidth,
    int                     inputHeight,
    int                     inputHeightPad,
    int                     pad_left,
    int                     pad_top,
    int                     stride_y,
    int                     outputHeight,
    int                     enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0) >> 2, get_global_id(1) * stride_y + coord.z * inputHeightPad, get_global_id(0) >> 2, get_global_id(0) >> 2);

    float4 src00 = read_imagef(input, coord_in.xy);
    coord_in.zw = coord_in.xy + (int2)(1, 1);
    float4 src01 = read_imagef(input, coord_in.zy);
    float4 src10 = read_imagef(input, coord_in.xw);
    float4 src11 = read_imagef(input, coord_in.zw);
    coord_in.y += 2;
    float4 src20 = read_imagef(input, coord_in.xy);
    float4 src21 = read_imagef(input, coord_in.zy);

    coord.x >>= 1;
    coord.y = coord.z * outputHeight + coord.y;
    coord.zw = coord.xx + (int2)(1, 2);
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 1, stride_y);

    float8 data00 = src00.xyzyzwzw;
    float4 data01 = (float4)(src01.x, src00.w, src01.x, src01.y);
    float8 data10 = src10.xyzyzwzw;
    float4 data11 = (float4)(src11.x, src10.w, src11.x, src11.y);
    float8 data20 = src20.xyzyzwzw;
    float4 data21 = (float4)(src21.x, src20.w, src21.x, src21.y);

    data00 += data10;
    data01 += data11;
    data00 += data20;
    data01 += data21;

    float4 result = (float4)(data00.s0, data00.s3, data00.s6, data01.y) + (float4)(data00.s1, data00.s4, data00.s7, data01.z);
    result += (float4)(data00.s2, data00.s5, data01.x, data01.w);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }
    result *= scale;

    write_imagef(output, coord.xy, result.xyxy);
    write_imagef(output, coord.zy, result.zwzw);
}

__kernel void gpuPooling_AvgNoPadFP32_K3S1_M4_2D
    (
    __read_only  image2d_t  input,
    __write_only image2d_t  output,
    int                     inputWidth,
    int                     inputHeight,
    int                     inputHeightPad,
    int                     pad_left,
    int                     pad_top,
    int                     stride_y,
    int                     outputHeight,
    int                     enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0) >> 2, get_global_id(1) * stride_y + coord.z * inputHeightPad, get_global_id(0) >> 2, get_global_id(0) >> 2);

    float4 src00 = read_imagef(input, coord_in.xy);
    coord_in.zw = coord_in.xy + (int2)(1, 1);
    float4 src01 = read_imagef(input, coord_in.zy);
    float4 src10 = read_imagef(input, coord_in.xw);
    float4 src11 = read_imagef(input, coord_in.zw);
    coord_in.y += 2;
    float4 src20 = read_imagef(input, coord_in.xy);
    float4 src21 = read_imagef(input, coord_in.zy);

    coord.x >>= 2;
    coord.y = coord.z * outputHeight + coord.y;
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 1, stride_y);

    float8 data00 = src00.xyzyzwzw;
    float4 data01 = (float4)(src01.x, src00.w, src01.x, src01.y);
    float8 data10 = src10.xyzyzwzw;
    float4 data11 = (float4)(src11.x, src10.w, src11.x, src11.y);
    float8 data20 = src20.xyzyzwzw;
    float4 data21 = (float4)(src21.x, src20.w, src21.x, src21.y);

    data00 += data10;
    data01 += data11;
    data00 += data20;
    data01 += data21;

    float4 result = (float4)(data00.s0, data00.s3, data00.s6, data01.y) + (float4)(data00.s1, data00.s4, data00.s7, data01.z);
    result += (float4)(data00.s2, data00.s5, data01.x, data01.w);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }

    result *= scale;

    write_imagef(output, coord.xy, result);
}

__kernel void gpuPooling_AvgNoPadFP32_K3S2_M1_2D
    (
    __read_only  image2d_t  input,
    __write_only image2d_t  output,
    int                     inputWidth,
    int                     inputHeight,
    int                     inputHeightPad,
    int                     pad_left,
    int                     pad_top,
    int                     stride_y,
    int                     outputHeight,
    int                     enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0) >> 1, (get_global_id(1) * stride_y) + coord.z * inputHeightPad, get_global_id(0), get_global_id(0));

    float4 src00 = read_imagef(input, coord_in.xy);
    coord_in.zw = coord_in.xx + (int2)(1, 2);
    float4 src01 = read_imagef(input, coord_in.zy);
    float4 src02 = read_imagef(input, coord_in.wy);
    coord_in.y ++;
    float4 src10 = read_imagef(input, coord_in.xy);
    float4 src11 = read_imagef(input, coord_in.zy);
    float4 src12 = read_imagef(input, coord_in.wy);
    coord_in.y ++;
    float4 src20 = read_imagef(input, coord_in.xy);
    float4 src21 = read_imagef(input, coord_in.zy);
    float4 src22 = read_imagef(input, coord_in.wy);

    coord.y = coord.z * outputHeight + coord.y;
    coord.zw = coord.xx + (int2)(1, 2);
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 2, stride_y);

    float8 data00 = (float8)(src00.xyz, src00.zw, src01.xxy);
    float4 data01 = (float4)(src01.zzw, src02.x);
    float8 data10 = (float8)(src10.xyz, src10.zw, src11.xxy);
    float4 data11 = (float4)(src11.zzw, src12.x);
    float8 data20 = (float8)(src20.xyz, src20.zw, src21.xxy);
    float4 data21 = (float4)(src21.zzw, src22.x);

    data00 += data10;
    data01 += data11;
    data00 += data20;
    data01 += data21;

    float4 result = (float4)(data00.s0, data00.s3, data00.s6, data01.y) + (float4)(data00.s1, data00.s4, data00.s7, data01.z);
    result += (float4)(data00.s2, data00.s5, data01.x, data01.w);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }
    result *= scale;

    write_imagef(output, coord.xy, result.xxxx);
    coord.x += 3;
    write_imagef(output, coord.zy, result.yyyy);
    write_imagef(output, coord.wy, result.zzzz);
    write_imagef(output, coord.xy, result.wwww);
}

__kernel void gpuPooling_AvgNoPadFP32_K3S2_M2_2D
    (
    __read_only  image2d_t  input,
    __write_only image2d_t  output,
    int                     inputWidth,
    int                     inputHeight,
    int                     inputHeightPad,
    int                     pad_left,
    int                     pad_top,
    int                     stride_y,
    int                     outputHeight,
    int                     enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0) >> 1, (get_global_id(1) * stride_y) + coord.z * inputHeightPad, get_global_id(0), get_global_id(0));

    float4 src00 = read_imagef(input, coord_in.xy);
    coord_in.zw = coord_in.xx + (int2)(1, 2);
    float4 src01 = read_imagef(input, coord_in.zy);
    float4 src02 = read_imagef(input, coord_in.wy);
    coord_in.y ++;
    float4 src10 = read_imagef(input, coord_in.xy);
    float4 src11 = read_imagef(input, coord_in.zy);
    float4 src12 = read_imagef(input, coord_in.wy);
    coord_in.y ++;
    float4 src20 = read_imagef(input, coord_in.xy);
    float4 src21 = read_imagef(input, coord_in.zy);
    float4 src22 = read_imagef(input, coord_in.wy);

    coord.x >>= 1;
    coord.y = coord.z * outputHeight + coord.y;
    coord.zw = coord.xx + (int2)(1, 2);
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 2, stride_y);

    float8 data00 = (float8)(src00.xyz, src00.zw, src01.xxy);
    float4 data01 = (float4)(src01.zzw, src02.x);
    float8 data10 = (float8)(src10.xyz, src10.zw, src11.xxy);
    float4 data11 = (float4)(src11.zzw, src12.x);
    float8 data20 = (float8)(src20.xyz, src20.zw, src21.xxy);
    float4 data21 = (float4)(src21.zzw, src22.x);

    data00 += data10;
    data01 += data11;
    data00 += data20;
    data01 += data21;

    float4 result = (float4)(data00.s0, data00.s3, data00.s6, data01.y) + (float4)(data00.s1, data00.s4, data00.s7, data01.z);
    result += (float4)(data00.s2, data00.s5, data01.x, data01.w);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }
    result *= scale;

    write_imagef(output, coord.xy, result.xyxy);
    write_imagef(output, coord.zy, result.zwzw);
}

__kernel void gpuPooling_AvgNoPadFP32_K3S2_M4_2D
    (
    __read_only  image2d_t  input,
    __write_only image2d_t  output,
    int                     inputWidth,
    int                     inputHeight,
    int                     inputHeightPad,
    int                     pad_left,
    int                     pad_top,
    int                     stride_y,
    int                     outputHeight,
    int                     enable_tf
    )
{
    int4 coord = (int4)(get_global_id(0), get_global_id(1), get_global_id(2), get_global_id(0));
    int4 coord_in = (int4)(get_global_id(0) >> 1, (get_global_id(1) * stride_y) + coord.z * inputHeightPad, get_global_id(0), get_global_id(0));

    float4 src00 = read_imagef(input, coord_in.xy);
    coord_in.zw = coord_in.xx + (int2)(1, 2);
    float4 src01 = read_imagef(input, coord_in.zy);
    float4 src02 = read_imagef(input, coord_in.wy);
    coord_in.y ++;
    float4 src10 = read_imagef(input, coord_in.xy);
    float4 src11 = read_imagef(input, coord_in.zy);
    float4 src12 = read_imagef(input, coord_in.wy);
    coord_in.y ++;
    float4 src20 = read_imagef(input, coord_in.xy);
    float4 src21 = read_imagef(input, coord_in.zy);
    float4 src22 = read_imagef(input, coord_in.wy);

    coord.x >>= 2;
    coord.y = coord.z * outputHeight + coord.y;
    float4 scale = calculate_avg_scale4(3, inputWidth, inputHeight, pad_left, pad_top, 2, stride_y);

    float8 data00 = (float8)(src00.xyz, src00.zw, src01.xxy);
    float4 data01 = (float4)(src01.zzw, src02.x);
    float8 data10 = (float8)(src10.xyz, src10.zw, src11.xxy);
    float4 data11 = (float4)(src11.zzw, src12.x);
    float8 data20 = (float8)(src20.xyz, src20.zw, src21.xxy);
    float4 data21 = (float4)(src21.zzw, src22.x);

    data00 += data10;
    data01 += data11;
    data00 += data20;
    data01 += data21;

    float4 result = (float4)(data00.s0, data00.s3, data00.s6, data01.y) + (float4)(data00.s1, data00.s4, data00.s7, data01.z);
    result += (float4)(data00.s2, data00.s5, data01.x, data01.w);

    if (enable_tf == 0)
    {
        scale = 0.1111111111111111f;
    }
    result *= scale;

    write_imagef(output, coord.xy, result);
}

__kernel void gpuPooling_globalpooling_FP32_M4
    (
    __read_only  image2d_t  input,
    __write_only image2d_t  output,
                 int        kernel_size,
                 float      scale
    )
{
    int4 coord = (int4)(0, get_global_id(1), 0, get_global_id(1));
    float4 result = 0;

    do
    {
        float4 src00 = read_imagef(input, coord.xy);
        coord.x += 1;

        result = result + src00;
    } while (coord.x < kernel_size);

    float4 one = (float4)(1.0f, 1.0f, 1.0f, 1.0f);
    result.x = dot(result, one);

    result *= scale;

    write_imagef(output, coord.zy, result);
}

__kernel void gpuPooling_globalpooling_FP32_M1
    (
    __read_only  image2d_t  input,
    __write_only image2d_t  output,
                 int        kernel_size,
                 float      scale
    )
{
    int4 coord = (int4)(0, get_global_id(1), 0, get_global_id(1));
    float4 result = 0;

    do
    {
        float4 src00 = read_imagef(input, coord.xy);
        coord.x ++;

        result = result + src00;
    } while (coord.x < kernel_size);

    result *= scale;

    write_imagef(output, coord.zy, result);
}

__kernel void gpuPooling_globalpooling_U8_M4
    (
    __read_only  image2d_t  input,
    __write_only image2d_t  output,
                 int        kernel_size,
                 float      scale,
                 float      input_tail,
                 float      outputZP
    )
{
    int4 coord = (int4)(0, get_global_id(1), 0, get_global_id(1));
    uint4 sum = 0;

    do
    {
        uint4 src00 = read_imageui(input, coord.xy);
        coord.x += 1;

        sum = sum + src00;
    } while (coord.x < kernel_size);

    float4 one = (float4)(1.0f, 1.0f, 1.0f, 1.0f);
    float4 result = convert_float4(sum);
    result.x = dot(result, one);

    result.x = (result.x - input_tail) * scale + outputZP;
    sum = convert_uint4(convert_uchar4_sat(result));

    write_imageui(output, coord.zy, sum);
}

__kernel void gpuPooling_globalpooling_U8_M1
    (
    __read_only  image2d_t  input,
    __write_only image2d_t  output,
                 int        kernel_size,
                 float      scale,
                 float      input_tail,
                 float      outputZP
    )
{
    int4 coord = (int4)(0, get_global_id(1), 0, get_global_id(1));
    uint4 sum = 0;

    do
    {
        uint4 src00 = read_imageui(input, coord.xy);
        coord.x ++;

        sum = sum + src00;
    } while (coord.x < kernel_size);

    float4 result = convert_float4(sum);

    result.x = (result.x - input_tail) * scale + outputZP;
    sum = convert_uint4(convert_uchar4_sat(result));

    write_imageui(output, coord.zy, sum);
}
